# 정규화(Normalization)

> RDB 설계에서 무결성을 향상하고 저장 공간을 효율적으로 사용하기 위해,
> 데이터의 중복을 줄여 이상 현상(Anomaly)을 해결하는 과정

</br>

<aside>

`정규화 과정을 거쳐 테이블을 나누면 중복은 줄어들지만 성능이 무조건 증가하는 것은 아니다. **성능이 좋아질 수도 나빠질 수도 있다**. 따라서 서비스에 따라 선택적으로 정규화 과정을 진행해야 한다.`

</aside>

### 장점

데이터 중복 제거에 따라...

1. 저장 공간 효율화 (불필요 데이터 방지, 테이블 직관적 이해 및 DB 구조 확장 용이)
2. 데이터 무결성 보장 (이상 현상 방지)

### 단점

1. 쿼리 복잡성 증가 (JOIN 사용이 많아지기 때문) </br>
   → 대규모 RW 작업이 많은 환경에서는 반정규화 구조가 유리할 수 있음
2. 설계 및 관리 복잡성 증가

<aside>

</br>

---

</br>

`정규화는 여러가지 단계가 있지만, 대체적으로 1~3단계 정규화의 과정을 거친다.`

</aside>

## 1NF (제 1정규화)

> 모든 도메인이 더이상 분해될 수 없는 **원자값**만으로 구성되어야 한다.

| num | name | course_name     | score    |
| --- | ---- | --------------- | -------- |
| 1   | 홍철 | {c++, front}    | {90, 10} |
| 2   | 범석 | {codeforce, ds} | {7, 8}   |

한 개의 PK(`num`)에 대해 `course_name`이나 `score`이 여러 개의 값을 가지고 있어 원자값이 아니다. </br>
따라서 아래와 같이 분리한다.

| num | name | course_name | score |
| --- | ---- | ----------- | ----- |
| 1   | 홍철 | c++         | 90    |
| 1   | 홍철 | front       | 10    |
| 2   | 범석 | codeforce   | 7     |
| 2   | 범석 | ds          | 8     |

</br>

## 2NF (제 2정규화)

> 1NF를 만족하며 테이블의 모든 컬럼이 완전 함수 종속을 만족해야 한다.

### 완전 함수 종속?

= 부분 함수 종속성을 제거한 상태

= 릴레이션에서 PK의 일부 속성에만 종속되는 경우

= PK의 부분집합 키가 결정자가 되는 경우

| num | name | course_name | score |
| --- | ---- | ----------- | ----- |
| 1   | 홍철 | c++         | 90    |
| 1   | 홍철 | front       | 10    |
| 2   | 범석 | codeforce   | 7     |
| 2   | 범석 | ds          | 8     |

`{name, course_name}` 을 PK로 `score`이 결정된다. </br>
이 PK의 일부인 `name`으로 `num`이 결정된다.

따라서 아래와 같이 분리한다.

| num | name |
| --- | ---- |
| 1   | 홍철 |
| 2   | 범석 |

| name | course_name | score |
| ---- | ----------- | ----- |
| 홍철 | c++         | 90    |
| 홍철 | front       | 10    |
| 범석 | codeforce   | 7     |
| 범석 | ds          | 8     |

</br>

## 3NF (제 3정규화)

> 2NF를 만족하며 이행 함수 종속을 제거한 형태

- 일반적으로 3NF를 만족하면 정규화가 되었다고 한다.
- 대부분의 3NF 만족 DB는 삽입, 갱신, 삭제 이상이 발생하지 X

### 이행 함수 종속?

= `A→B` 와 `B→C`가 존재해 `A→C`가 되는 경우

| name | rank     | discount |
| ---- | -------- | -------- |
| 홍철 | 플래티넘 | 30%      |
| 범수 | 다이아   | 50%      |
| 가영 | 마스터   | 70%      |

`name이 → rank를` 결정하고 `rank가 → discount를` 결정하는데 결국 논리적으로 `name이 → discount를` 결정하게 된다.

따라서 아래와 같이 분리한다.

| name | rank     |
| ---- | -------- |
| 홍철 | 플래티넘 |
| 범수 | 다이아   |
| 가영 | 마스터   |

| rank     | discount |
| -------- | -------- |
| 플래티넘 | 30%      |
| 다이아   | 50%      |
| 마스터   | 70%      |

 </br>

## BCNF (보이스코드 정규화)

> 3NF를 만족하며 모든 결정자가 후보키인 상태

### 결정자?

= 함수 종속 관계 (X→Y)에서 특정 종속자를 결정짓는 요소(X)

- cf. Y: 종속자

| 학번 | 과목 | 강사 |
| ---- | ---- | ---- |
| 0000 | 수학 | 재석 |
| 0000 | 영어 | 명수 |
| 0001 | 수학 | 재석 |
| 0001 | 영어 | 준하 |

| 학번 | 과목        | 강사 |
| ---- | ----------- | ---- |
| NULL | 생활과 체육 | 하하 |

 </br>

`{학번, 수강명}` 또는 `{학번, 강사}`가 후보키가 되는데, </br>
만약 이때 하하라는 강사가 생활과 체육과목을 담당할 때 이를 삽입하면 학번이 NULL이 된다. </br>
(삽입 이상 발생)

강사 속성과 학번은 아무런 관계가 없는 것이다. </br>
즉, `강사` 속성이 결정자이지만 후보키가 아니므로 이 속성을 분리해야 한다.

따라서 아래와 같이 분리한다.

| 학번 | 강사 |
| ---- | ---- |
| 0000 | 재석 |
| 0000 | 명수 |
| 0001 | 재석 |
| 0001 | 준하 |

| 과목        | 강사 |
| ----------- | ---- |
| 수학        | 재석 |
| 영어        | 명수 |
| 영어        | 준하 |
| 생활과 체육 | 하하 |
